        -:    0:Source:pretty-printer.c
        -:    0:Graph:pretty-printer.gcno
        -:    0:Data:pretty-printer.gcda
        -:    0:Runs:3
        -:    0:Programs:1
        -:    1:#include "pretty-printer.h"
        -:    2:
        -:    3:const char* SYNTAXDIC[NUMOFSYNTAX + 1] = {
        -:    4:	"", "NAME", "program", "var", "array", "of", "begin", "end", "if", "then",
        -:    5:	"else", "procedure", "return", "call", "while", "do", "not", "or", "div",
        -:    6:	"and", "char", "integer", "boolean", "readln", "writeln", "true", "false",
        -:    7:	"INTEGER", "STRING", "+", "-", "*", "=", "<>", "<", "<=", ">", ">=",
        -:    8:	"(", ")", "[", "]", ":=", ".", ",", ":", ";", "read", "write", "break",
        -:    9:	"SPROGRAM", "SBLOCK", "SBLOCK_0", "SBLOCK_0_0", "SVARDEC", "SVARDEC_5",
        -:   10:	"SVARDEC_5_1", "SVARNAMES", "SVARNAMES_1", "SVARNAMES_1_0", "SVARNAME",
        -:   11:	"STYPE", "SSTDTYPE", "SARRTYPE", "SSUBPROGDEC", "SSUBPROGDEC_2",
        -:   12:	"SSUBPROGDEC_4", "SPROCEDURENAME", "SFORMPARAM", "SFORMPARAM_4",
        -:   13:	"SFORMPARAM_4_0", "SCOMPSTAT", "SCOMPSTAT_2", "SCOMPSTAT_2_0", "SSTAT",
        -:   14:	"SCONDSTAT", "SCONDSTAT_4", "SCONDSTAT_4_0", "SITERSTAT", "SEXITSTAT",
        -:   15:	"SCALLSTAT", "SCALLSTAT_2", "SCALLSTAT_2_0", "SEXPRS", "SEXPRS_1",
        -:   16:	"SEXPRS_1_0", "SRETSTAT", "SASSIGNSTAT", "SLEFTPART", "SVAR", "SVAR_1",
        -:   17:	"SVAR_1_0", "SEXPR", "SEXPR_1", "SEXPR_1_0", "SSIMPLEEXPR", "SSIMPLEEXPR_0",
        -:   18:	"SSIMPLEEXPR_0_0", "SSIMPLEEXPR_2", "SSIMPLEEXPR_2_0", "STERM", "STERM_1",
        -:   19:	"STERM_1_0", "SFACTOR", "SFACTOR_2", "SFACTOR_3", "SFACTOR_4", "SCONST",
        -:   20:	"SMULOP", "SADDOP", "SRELATOP", "SINSTAT", "SINSTAT_0", "SINSTAT_1",
        -:   21:	"SINSTAT_1_0", "SINSTAT_1_0_2", "SINSTAT_1_0_2_0", "SOUTSTAT", "SOUTSTAT_0",
        -:   22:	"SOUTSTAT_1", "SOUTSTAT_1_0", "SOUTSTAT_1_0_2", "SOUTSTAT_1_0_2_0",
        -:   23:	"SOUTFORM", "SOUTFORM_0", "SOUTFORM_0_1", "SOUTFORM_0_1_0", "SEMPTYSTAT", 
        -:   24:};
        -:   25:
        -:   26:int is_head_of_line;
        -:   27:
    12477:   28:SyntaxTreeNode* malloc_tree_node(){
    12477:   29:	SyntaxTreeNode *node = malloc(sizeof(SyntaxTreeNode));
    12477:   30:	if(node == NULL){
    #####:   31:		printf("error i could not malloc\n");
    #####:   32:		exit(-1);
        -:   33:	}
    12477:   34:	node->parent = NULL;
    12477:   35:	node->brother = NULL;
    12477:   36:	node->child = NULL;
        -:   37:
    12477:   38:	return node;
        -:   39:}
        -:   40:
    24957:   41:void free_tree(SyntaxTreeNode* node){
    49914:   42:	if(node == NULL) return;
        -:   43:
    12477:   44:	free_tree(node->child);
    12477:   45:	free_tree(node->brother);
        -:   46:
    12477:   47:	free(node);
    12477:   48:	node = NULL;
        -:   49:}
        -:   50:
    12477:   51:void print_tree_node(SyntaxTreeNode* node){
    12477:   52:	printf("%9p ", node);
    12477:   53:	printf("%16s ", SYNTAXDIC[node->s_elem_it]);
    12477:   54:	printf("l%3d ", node->line_num);
    12477:   55:	printf("d%d ", node->indent_depth);
    12477:   56:	printf("w%d ", node->iter_depth);
    21070:   57:	printf("%s ", node->parse_result == PARSERESULT_MATCH ? "T" : 
     9745:   58:				node->parse_result == PARSERESULT_DIFFERENCE ? "F" :
     1152:   59:				node->parse_result == PARSERESULT_EMPTY ? "E" : "A");
    12477:   60:	printf("c%9p ", node->child);
    12477:   61:	printf("b%9p ", node->brother);
    12477:   62:	printf("%s ", node->string_attr);
    12477:   63:	printf("\n");	
    12477:   64:}
        -:   65:
    24957:   66:void debug_tree(SyntaxTreeNode* node){
    49914:   67:	if(node == NULL) return;
        -:   68:
    12477:   69:	print_tree_node(node);
        -:   70:
    12477:   71:	debug_tree(node->child);
    12477:   72:	debug_tree(node->brother);
        -:   73:}
        -:   74:
    #####:   75:void dump_expected_token(int s_elem_it){
        -:   76:	int i;
    #####:   77:	int max_it = 1;
        -:   78:
    #####:   79:	if(s_elem_array[s_elem_it].op == SELEMOP_ONE_OF){
    #####:   80:		max_it = s_elem_array[s_elem_it].children_num;
        -:   81:	}
        -:   82:
    #####:   83:	for(i = 0; i < max_it; i++){
    #####:   84:		int child_it = s_elem_array[s_elem_it].children[i];
    #####:   85:		if(s_elem_array[child_it].op == SELEMOP_TERMINATOR){
    #####:   86:			printf("%s,", SYNTAXDIC[child_it]);
        -:   87:		}else{
    #####:   88:			dump_expected_token(child_it);
        -:   89:		}
        -:   90:	}	
    #####:   91:}
        -:   92:
    #####:   93:int find_error_tree(SyntaxTreeNode* node){
    #####:   94:	if(node == NULL) return PARSERESULT_EMPTY;
        -:   95:
    #####:   96:	if(node->parse_result == PARSERESULT_ACCIDENT){
    #####:   97:		if(find_error_tree(node->child) == PARSERESULT_ACCIDENT){
        -:   98:			/*
        -:   99:			print_tree_node(this);
        -:  100:			printf("'S CHILD\n");
        -:  101:			*/
    #####:  102:			printf("\tin parsing %s (line %d)\n", SYNTAXDIC[node->s_elem_it], node->line_num);
    #####:  103:			return PARSERESULT_ACCIDENT;
        -:  104:		}
        -:  105:	}
        -:  106:
    #####:  107:	if(find_error_tree(node->brother) == PARSERESULT_ACCIDENT){
    #####:  108:		return PARSERESULT_ACCIDENT;
        -:  109:	}
        -:  110:
    #####:  111:	if(node->s_elem_it <= NUMOFTOKEN){
    #####:  112:		if(node->parse_result == PARSERESULT_DIFFERENCE){
        -:  113:			/*
        -:  114:			print_tree_node(this);
        -:  115:			printf("needs this token\n");
        -:  116:			*/
    #####:  117:			printf("expected ' %s ' token (line %d)\n", SYNTAXDIC[node->s_elem_it], node->line_num);
    #####:  118:			return PARSERESULT_ACCIDENT;
        -:  119:		}
    #####:  120:		else if(node->parse_result == PARSERESULT_ACCIDENT){
        -:  121:			/*
        -:  122:			print_tree_node(this);
        -:  123:			printf("this token is illegal\n");
        -:  124:			*/
    #####:  125:			printf("unauthorized %s token (line %d)\n", SYNTAXDIC[node->s_elem_it], node->line_num);
    #####:  126:			return PARSERESULT_ACCIDENT;
        -:  127:		}
        -:  128:	}
        -:  129:
    #####:  130:	else if(node->parse_result == PARSERESULT_EMPTY || node->parse_result == PARSERESULT_DIFFERENCE){
        -:  131:		/*
        -:  132:		print_tree_node(this);
        -:  133:		printf("needs this token\n");
        -:  134:		*/
    #####:  135:		printf("expected %s (line %d) ", SYNTAXDIC[node->s_elem_it], node->line_num);
    #####:  136:		printf("(ex.");
    #####:  137:		dump_expected_token(node->s_elem_it);
    #####:  138:		printf(")\n");
    #####:  139:		return PARSERESULT_ACCIDENT;
        -:  140:	}
        -:  141:
    #####:  142:	return PARSERESULT_EMPTY;
        -:  143:}
        -:  144:
    12474:  145:int indent_difference(int grampa_s_elem_it, int parent_s_elem_it, int child_s_elem_it){
        -:  146:
    12474:  147:	if(grampa_s_elem_it == SITERSTAT &&
       63:  148:		parent_s_elem_it == SSTAT && child_s_elem_it == SCOMPSTAT){
        7:  149:		return -1;
        -:  150:	}
    12467:  151:	if(grampa_s_elem_it == SCONDSTAT &&
      153:  152:		parent_s_elem_it == SSTAT && child_s_elem_it == SCOMPSTAT){
        4:  153:		return -1;
        -:  154:	}
    12463:  155:	if(grampa_s_elem_it == SCONDSTAT_4_0 &&
       63:  156:		parent_s_elem_it == SSTAT && child_s_elem_it == SCOMPSTAT){
        3:  157:		return -1;
        -:  158:	}
        -:  159:
    12460:  160:	if(parent_s_elem_it == SBLOCK && child_s_elem_it == SBLOCK_0)
        3:  161:		return 1;
    12457:  162:	if(parent_s_elem_it == SSUBPROGDEC && child_s_elem_it == SSUBPROGDEC_4)
       13:  163:		return 1;
    12444:  164:	if(parent_s_elem_it == SITERSTAT && child_s_elem_it == SSTAT)
        7:  165:		return 1;
    12437:  166:	if(parent_s_elem_it == SCONDSTAT && child_s_elem_it == SSTAT)
       26:  167:		return 1;
    12411:  168:	if(parent_s_elem_it == SCONDSTAT_4_0 && child_s_elem_it == SSTAT)
       14:  169:		return 1;
    12397:  170:	if(parent_s_elem_it == SCOMPSTAT && child_s_elem_it == SSTAT)
       30:  171:		return 1;
    12367:  172:	if(parent_s_elem_it == SCOMPSTAT && child_s_elem_it == SCOMPSTAT_2)
       30:  173:		return 1;
    12337:  174:	if(parent_s_elem_it == SVARDEC && child_s_elem_it != TVAR)
       50:  175:		return 1;
        -:  176:
    12287:  177:	return 0;
        -:  178:}
        -:  179:
    12477:  180:void preformat_tree(SyntaxTreeNode* parent, SyntaxTreeNode* this, int indent_depth){
        -:  181:	int i;
    12477:  182:	int g_it = (parent == NULL) ? 0 : parent->s_elem_it;
    12477:  183:	int p_it = (this   == NULL) ? 0 : this  ->s_elem_it;
        -:  184:	SyntaxTreeNode* node;
    24954:  185:	if(this == NULL) return;
        -:  186:
    12477:  187:	this->indent_depth = indent_depth;
        -:  188:
    12477:  189:	node = this->child;
    24951:  190:	for(i = 0; node != NULL; i++){
    12474:  191:		int indent = indent_depth + indent_difference(g_it, p_it, node->s_elem_it);
    12474:  192:		preformat_tree(this, node, indent);
    12474:  193:		node = node->brother;
        -:  194:	}
        -:  195:}
        -:  196:
    24957:  197:void print_tree(SyntaxTreeNode* node){
    24957:  198:	if(node == NULL) return;
        -:  199:
    12477:  200:	if(node->s_elem_it == TPROGRAM) {
        3:  201:		printf("%s", node->string_attr);
        3:  202:		is_head_of_line = 0;
        3:  203:		print_tree(node->child);
        3:  204:		print_tree(node->brother);
        3:  205:		return;
        -:  206:	}
        -:  207:
    12474:  208:	if(node->parse_result != PARSERESULT_MATCH || node->s_elem_it > NUMOFTOKEN){
    11343:  209:		print_tree(node->child);
    11343:  210:		print_tree(node->brother);
    11343:  211:		return;
        -:  212:	}
        -:  213:
     1131:  214:	if(node->s_elem_it == TEND || node->s_elem_it == TELSE){
       44:  215:		is_head_of_line = 1;
        -:  216:	}
        -:  217:
     1131:  218:	if(is_head_of_line){
        -:  219:		int i;
      245:  220:		printf("\n");
      899:  221:		for(i = 0; i < node->indent_depth; i++){
      654:  222:			printf("\t");
        -:  223:		}
      245:  224:		is_head_of_line = 0;
        -:  225:	}
     1559:  226:	else if(node->s_elem_it == TSEMI || node->s_elem_it == TCOMMA ||
     1343:  227:			node->s_elem_it == TDOT || 
      738:  228:			(node->s_elem_it == TLPAREN && node->parent->s_elem_it != SFACTOR_2)){
        -:  229:		/* not print " " before print token */
        -:  230:	}
        -:  231:	else{
        -:  232:		/* print " " before print token */
      614:  233:		printf(" ");
        -:  234:	}
        -:  235:
     1131:  236:	if(node->s_elem_it == TSTRING){
       33:  237:		printf("'%s'", node->string_attr);
        -:  238:	}
        -:  239:	else{
     1098:  240:		printf("%s", node->string_attr);
        -:  241:	}
        -:  242:
     2112:  243:	if(node->s_elem_it == TSEMI || node->s_elem_it == TBEGIN ||
     2903:  244:		node->s_elem_it == TDO || node->s_elem_it == TTHEN || 
     1882:  245:		node->s_elem_it == TELSE || node->s_elem_it == TVAR){
      207:  246:		is_head_of_line = 1;
        -:  247:	}
        -:  248:
     1131:  249:	print_tree(node->child);
     1131:  250:	print_tree(node->brother);
        -:  251:}
        -:  252:
        3:  253:int main(int nc, char *np[]) {
        -:  254:	SyntaxTreeNode *node_SPROGRAM;
        -:  255:
        3:  256:	if(nc < 2) {
    #####:  257:		printf("File name id not given.\n");
    #####:  258:		exit(-1);
        -:  259:	}
        -:  260:
        3:  261:	if(init_scan(np[1]) < 0) {
    #####:  262:		printf("File %s can not open.\n", np[1]);
    #####:  263:		exit(-1);
        -:  264:	}
        -:  265:
        3:  266:	init_parse();
        -:  267:
        3:  268:	node_SPROGRAM = parse(SPROGRAM, 0);
        -:  269:
        3:  270:	if(node_SPROGRAM->parse_result == PARSERESULT_MATCH){
        3:  271:		preformat_tree(NULL, node_SPROGRAM, 0);
        3:  272:		print_tree(node_SPROGRAM);
        3:  273:		printf("\n");
        3:  274:		debug_tree(node_SPROGRAM);
        -:  275:	}
        -:  276:	else{
    #####:  277:		debug_tree(node_SPROGRAM);
    #####:  278:		printf("syntax error found.\ndetail:\n");
    #####:  279:		find_error_tree(node_SPROGRAM);
        -:  280:	}
        -:  281:
        3:  282:	free_tree(node_SPROGRAM);
        3:  283:	end_scan();
        -:  284:
        3:  285:	return 0;
        -:  286:}
        -:  287:
